<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DTS: dtsPSock.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dtsPSock.c File Reference</h1><a class="el" href="structDTS.html">DTS</a> parallel socket transfer routines.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;pthread.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;unistd.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;netdb.h&gt;</code><br>
<code>#include &lt;ctype.h&gt;</code><br>
<code>#include &lt;sys/types.h&gt;</code><br>
<code>#include &lt;sys/stat.h&gt;</code><br>
<code>#include &lt;sys/time.h&gt;</code><br>
<code>#include &lt;fcntl.h&gt;</code><br>
<code>#include &lt;sys/errno.h&gt;</code><br>
<code>#include &lt;sys/socket.h&gt;</code><br>
<code>#include &lt;netinet/in.h&gt;</code><br>
<code>#include &lt;netinet/tcp.h&gt;</code><br>
<code>#include &lt;arpa/inet.h&gt;</code><br>
<code>#include &quot;dts.h&quot;</code><br>
<code>#include &quot;dtsPSock.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#22e10c7b49ab319242b4ae093fb4dc2d">dts_printPHdr</a> (char *s, phdr *h)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#7b8bfbc4d0af5e42cc3f688fc754a974">psSpawnThreads</a> (void *worker, int nthreads, char *dir, char *fname, long fsize, int mode, int port, char *host, int verbose, pthread_t *tids)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn a worker thread for the transfer.  <a href="#7b8bfbc4d0af5e42cc3f688fc754a974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#160295877b92430888f76329f60f813e">psCollectThreads</a> (int nthreads, pthread_t *tids)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect worker threads for the transfer.  <a href="#160295877b92430888f76329f60f813e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#bfb767ce2c3944eca4a451bd95e9cbdc">psSendFile</a> (void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a file to a remote <a class="el" href="structDTS.html">DTS</a>.  <a href="#bfb767ce2c3944eca4a451bd95e9cbdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#7cb70ee251aba58b0803cb0cc1cb3323">psReceiveFile</a> (void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a file from a remote <a class="el" href="structDTS.html">DTS</a>.  <a href="#7cb70ee251aba58b0803cb0cc1cb3323"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#234716badb2257ccba58905bc7001c2c">psSendStripe</a> (int sock, unsigned char *dbuf, long offset, int tnum, long maxbytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do actual transfer of data stripe to the socket.  <a href="#234716badb2257ccba58905bc7001c2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#e819e3619a06be32cf0a12a113450bc4">psReceiveStripe</a> (int sock, long offset, int tnum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data stripe from the socket connection.  <a href="#e819e3619a06be32cf0a12a113450bc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#377827adf8f79dde8c5fa17c6174080f">psComputeStripe</a> (long fsize, int nthreads, int tnum, long *chsize, long *start, long *end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the various parameters of a 'stripe'.  <a href="#377827adf8f79dde8c5fa17c6174080f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#aced9ab6c747ee655426565b1be52e8e">svc_mutex</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dtsPSock_8c.html#51132e6b05a1239c31e59a31a4b7b46d">psock_checksum_policy</a> = CS_CHUNK</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="954099a1bb9677f24d8598fb9e27a790"></a><!-- doxytag: member="dtsPSock.c::err_return" ref="954099a1bb9677f24d8598fb9e27a790" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>err_return</b> = -1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9c89e7ff1fbfe74ed32f3bb6b69193f"></a><!-- doxytag: member="dtsPSock.c::thread_sem" ref="e9c89e7ff1fbfe74ed32f3bb6b69193f" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_sem</b> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc3bb7a68b2cea3f7db95cb764bce904"></a><!-- doxytag: member="dtsPSock.c::io_tv" ref="bc3bb7a68b2cea3f7db95cb764bce904" args="" -->
struct timeval&nbsp;</td><td class="memItemRight" valign="bottom"><b>io_tv</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e3d0548c599124f2df64c499a8b0ee6"></a><!-- doxytag: member="dtsPSock.c::queue_delay" ref="4e3d0548c599124f2df64c499a8b0ee6" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>queue_delay</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bfe1ab56be631e48e5edc9f0f1381486"></a><!-- doxytag: member="dtsPSock.c::first_write" ref="bfe1ab56be631e48e5edc9f0f1381486" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>first_write</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="99390fcf722f24689439904d1b546dce"></a><!-- doxytag: member="dtsPSock.c::dts" ref="99390fcf722f24689439904d1b546dce" args="" -->
<a class="el" href="structDTS.html">DTS</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>dts</b></td></tr>

</table>
<hr><h2>Detailed Description</h2>
<a class="el" href="structDTS.html">DTS</a> parallel socket transfer routines. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Mike Fitzpatrick, NOAO </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>6/10/09 </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="22e10c7b49ab319242b4ae093fb4dc2d"></a><!-- doxytag: member="dtsPSock.c::dts_printPHdr" ref="22e10c7b49ab319242b4ae093fb4dc2d" args="(char *s, phdr *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dts_printPHdr           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">phdr *&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
DTS_PRINTHDR -- Debug Utility. 
</div>
</div><p>
<a class="anchor" name="160295877b92430888f76329f60f813e"></a><!-- doxytag: member="dtsPSock.c::psCollectThreads" ref="160295877b92430888f76329f60f813e" args="(int nthreads, pthread_t *tids)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psCollectThreads           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_t *&nbsp;</td>
          <td class="paramname"> <em>tids</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collect worker threads for the transfer. 
<p>
PSCOLLECTTHREADS -- Collect the worker threads for the transfer. Our onl job here is start a thread to rejoin the previously createed threads.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nthreads</em>&nbsp;</td><td>number of threads to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tids</em>&nbsp;</td><td>thread IDs </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>status code </dd></dl>

<p>Referenced by <a class="el" href="dtsPull_8c_source.html#l00107">dts_xferPullFile()</a>, <a class="el" href="dtsPush_8c_source.html#l00108">dts_xferPushFile()</a>, <a class="el" href="dtsPush_8c_source.html#l00370">dts_xferReceiveFile()</a>, and <a class="el" href="dtsPull_8c_source.html#l00358">dts_xferSendFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="377827adf8f79dde8c5fa17c6174080f"></a><!-- doxytag: member="dtsPSock.c::psComputeStripe" ref="377827adf8f79dde8c5fa17c6174080f" args="(long fsize, int nthreads, int tnum, long *chsize, long *start, long *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">psComputeStripe           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>fsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>chsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the various parameters of a 'stripe'. 
<p>
PSCOMPUTESTRIPE -- Compute the parameters of a data stripe given the file size and number of worker threads.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fsize</em>&nbsp;</td><td>file size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nthreads</em>&nbsp;</td><td>numbers of threads being processed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tnum</em>&nbsp;</td><td>this thread number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chsize</em>&nbsp;</td><td>chunk size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>starting byte number of stripe (output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>ending byte number of stripe (output)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing</dd></dl>
UDTCOMPUTESTRIPE -- Compute the parameters of a data stripe given the file size and number of worker threads.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fsize</em>&nbsp;</td><td>file size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nthreads</em>&nbsp;</td><td>numbers of threads being processed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tnum</em>&nbsp;</td><td>this thread number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chsize</em>&nbsp;</td><td>chunk size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>starting byte number of stripe (output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>ending byte number of stripe (output)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

<p>References <a class="el" href="dtsLog_8c_source.html#l00301">dtsErrLog()</a>.</p>

<p>Referenced by <a class="el" href="dtsPSock_8c_source.html#l00083">psSpawnThreads()</a>, and <a class="el" href="dtsUDT_8c_source.html#l00088">udtSpawnThreads()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7cb70ee251aba58b0803cb0cc1cb3323"></a><!-- doxytag: member="dtsPSock.c::psReceiveFile" ref="7cb70ee251aba58b0803cb0cc1cb3323" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">psReceiveFile           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a file from a remote <a class="el" href="structDTS.html">DTS</a>. 
<p>
psReceiveFile -- Receive a file from a remote <a class="el" href="structDTS.html">DTS</a>.<p>
This function can be called to read a portion of a file from a remote host. Arguments are passed in through a generic 'data' pointer to the psArg struct defined for this 'stripe' of the data.<p>
In this procedure, we act as a client in the connection, i.e. the transfer won't begin until we connect to a remote server sending the data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>caller thread data </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

<p>References <a class="el" href="dtsFileUtil_8c_source.html#l00141">dts_fileOpen()</a>, <a class="el" href="dtsFileUtil_8c_source.html#l00398">dts_fileWrite()</a>, <a class="el" href="dtsFileUtil_8c_source.html#l00608">dts_makePath()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00222">dts_openClientSocket()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00065">dts_openServerSocket()</a>, <a class="el" href="dtsFileUtil_8c_source.html#l00207">dts_preAlloc()</a>, <a class="el" href="dtsSandbox_8c_source.html#l00042">dts_sandboxPath()</a>, <a class="el" href="dtsSem_8c_source.html#l00219">dts_semDecr()</a>, <a class="el" href="dtsLog_8c_source.html#l00301">dtsErrLog()</a>, <a class="el" href="dtsLog_8c_source.html#l00069">dtsLog()</a>, <a class="el" href="dtsLog_8c_source.html#l00362">dtsTimeLog()</a>, <a class="el" href="dtsPSock_8c_source.html#l00786">psReceiveStripe()</a>, and <a class="el" href="dtsPSock_8c_source.html#l00041">svc_mutex</a>.</p>

<p>Referenced by <a class="el" href="dtsPull_8c_source.html#l00107">dts_xferPullFile()</a>, and <a class="el" href="dtsPush_8c_source.html#l00370">dts_xferReceiveFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e819e3619a06be32cf0a12a113450bc4"></a><!-- doxytag: member="dtsPSock.c::psReceiveStripe" ref="e819e3619a06be32cf0a12a113450bc4" args="(int sock, long offset, int tnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uchar * psReceiveStripe           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tnum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data stripe from the socket connection. 
<p>
psReceiveStripe -- Do the actual transfer of the data stripe to the client connection. A 'stripe' of data is actually transferred in much smaller 'chunks' which can be tuned to be optimal for the given connection. The checksum policy allows us to perform a checksum of the data either for the entire stripe, or for each individual chunk. The former is generally more efficient as it involves fewer round-trips to the client (i.e. send the checksum and wait for verification before sending next chunk). File-level checksum policy is enforced by our parent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>socket descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>file offset for this stripe </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tnum</em>&nbsp;</td><td>thread (i.e. stripe) number</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data read </dd></dl>

<p>References <a class="el" href="dtsUtil_8c_source.html#l01319">dts_debugLevel()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00514">dts_sockRead()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00597">dts_sockWrite()</a>, <a class="el" href="dtsLog_8c_source.html#l00301">dtsErrLog()</a>, <a class="el" href="dtsLog_8c_source.html#l00362">dtsTimeLog()</a>, and <a class="el" href="dtsPSock_8c_source.html#l00046">psock_checksum_policy</a>.</p>

<p>Referenced by <a class="el" href="dtsPSock_8c_source.html#l00397">psReceiveFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="bfb767ce2c3944eca4a451bd95e9cbdc"></a><!-- doxytag: member="dtsPSock.c::psSendFile" ref="bfb767ce2c3944eca4a451bd95e9cbdc" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">psSendFile           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a file to a remote <a class="el" href="structDTS.html">DTS</a>. 
<p>
psSendFile -- Send a file to a remote <a class="el" href="structDTS.html">DTS</a>.<p>
This function can be called to send a portion of a file to a remote host. Arguments are passed in through a generic 'data' pointer to the psArg struct defined for this 'stripe' of the data.<p>
In this procedure, we act as a server, i.e. we open the specified tcp/ip socket and wait for a client connection before beginning any transfer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>caller thread data </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

<p>References <a class="el" href="dtsFileUtil_8c_source.html#l00172">dts_fileClose()</a>, <a class="el" href="dtsFileUtil_8c_source.html#l00141">dts_fileOpen()</a>, <a class="el" href="dtsFileUtil_8c_source.html#l00363">dts_fileRead()</a>, <a class="el" href="dtsFileUtil_8c_source.html#l00608">dts_makePath()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00222">dts_openClientSocket()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00065">dts_openServerSocket()</a>, <a class="el" href="dtsSandbox_8c_source.html#l00042">dts_sandboxPath()</a>, <a class="el" href="dtsSem_8c_source.html#l00219">dts_semDecr()</a>, <a class="el" href="dtsLog_8c_source.html#l00301">dtsErrLog()</a>, <a class="el" href="dtsLog_8c_source.html#l00362">dtsTimeLog()</a>, <a class="el" href="dtsPSock_8c_source.html#l00604">psSendStripe()</a>, and <a class="el" href="dtsPSock_8c_source.html#l00041">svc_mutex</a>.</p>

<p>Referenced by <a class="el" href="dtsPush_8c_source.html#l00108">dts_xferPushFile()</a>, and <a class="el" href="dtsPull_8c_source.html#l00358">dts_xferSendFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="234716badb2257ccba58905bc7001c2c"></a><!-- doxytag: member="dtsPSock.c::psSendStripe" ref="234716badb2257ccba58905bc7001c2c" args="(int sock, unsigned char *dbuf, long offset, int tnum, long maxbytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psSendStripe           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>dbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>maxbytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do actual transfer of data stripe to the socket. 
<p>
psSendStripe -- Do the actual transfer of the data stripe to the client connection. A 'stripe' of data is actually transferred in much smaller 'chunks' which can be tuned to be optimal for the given connection. The checksum policy allows us to perform a checksum of the data either for the entire stripe, or for each individual chunk. The former is generally more efficient as it involves fewer round-trips to the client (i.e. send the checksum and wait for verification before sending next chunk). File-level checksum policy is enforced by our parent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>socket descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dbuf</em>&nbsp;</td><td>data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>file offset for this stripe </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tnum</em>&nbsp;</td><td>thread number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxbytes</em>&nbsp;</td><td>max bytes to transfer</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of chunks sent </dd></dl>

<p>References <a class="el" href="dtsUtil_8c_source.html#l01319">dts_debugLevel()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00514">dts_sockRead()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00597">dts_sockWrite()</a>, <a class="el" href="dtsLog_8c_source.html#l00301">dtsErrLog()</a>, <a class="el" href="dtsLog_8c_source.html#l00362">dtsTimeLog()</a>, and <a class="el" href="dtsPSock_8c_source.html#l00046">psock_checksum_policy</a>.</p>

<p>Referenced by <a class="el" href="dtsPSock_8c_source.html#l00211">psSendFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7b8bfbc4d0af5e42cc3f688fc754a974"></a><!-- doxytag: member="dtsPSock.c::psSpawnThreads" ref="7b8bfbc4d0af5e42cc3f688fc754a974" args="(void *worker, int nthreads, char *dir, char *fname, long fsize, int mode, int port, char *host, int verbose, pthread_t *tids)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int psSpawnThreads           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>fsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_t *&nbsp;</td>
          <td class="paramname"> <em>tids</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spawn a worker thread for the transfer. 
<p>
PSSPAWNTHREADS -- Spawn a worker thread for the transfer. All we do here is start a thread to run the function passed in. This may be used to either read or write the data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>worker function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nthreads</em>&nbsp;</td><td>number of threads to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>working directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fname</em>&nbsp;</td><td>file name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fsize</em>&nbsp;</td><td>file size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>transfer mode (push or pull) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>client base port number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>host</em>&nbsp;</td><td>client host name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>verbose</em>&nbsp;</td><td>verbose output flag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tids</em>&nbsp;</td><td>thread id array</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>status code </dd></dl>

<p>References <a class="el" href="dtsLog_8c_source.html#l00301">dtsErrLog()</a>, and <a class="el" href="dtsPSock_8c_source.html#l00929">psComputeStripe()</a>.</p>

<p>Referenced by <a class="el" href="dtsPull_8c_source.html#l00107">dts_xferPullFile()</a>, <a class="el" href="dtsPush_8c_source.html#l00108">dts_xferPushFile()</a>, <a class="el" href="dtsPush_8c_source.html#l00370">dts_xferReceiveFile()</a>, and <a class="el" href="dtsPull_8c_source.html#l00358">dts_xferSendFile()</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="51132e6b05a1239c31e59a31a4b7b46d"></a><!-- doxytag: member="dtsPSock.c::psock_checksum_policy" ref="51132e6b05a1239c31e59a31a4b7b46d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="dtsPSock_8c.html#51132e6b05a1239c31e59a31a4b7b46d">psock_checksum_policy</a> = CS_CHUNK          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FIXME -- CS_STRIPE and CS_PACKET not working...... 
<p>Referenced by <a class="el" href="dtsSockUtil_8c_source.html#l00514">dts_sockRead()</a>, <a class="el" href="dtsSockUtil_8c_source.html#l00597">dts_sockWrite()</a>, <a class="el" href="dtsPSock_8c_source.html#l00786">psReceiveStripe()</a>, and <a class="el" href="dtsPSock_8c_source.html#l00604">psSendStripe()</a>.</p>

</div>
</div><p>
<a class="anchor" name="aced9ab6c747ee655426565b1be52e8e"></a><!-- doxytag: member="dtsPSock.c::svc_mutex" ref="aced9ab6c747ee655426565b1be52e8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="dtsPSock_8c.html#aced9ab6c747ee655426565b1be52e8e">svc_mutex</a> = PTHREAD_MUTEX_INITIALIZER          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex lock for thread startup to protect file I/O. 
<p>Referenced by <a class="el" href="dtsPSock_8c_source.html#l00397">psReceiveFile()</a>, and <a class="el" href="dtsPSock_8c_source.html#l00211">psSendFile()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Apr 11 11:51:12 2014 for DTS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
