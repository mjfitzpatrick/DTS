\hypertarget{dtsUDT_8c}{
\section{dtsUDT.c File Reference}
\label{dtsUDT_8c}\index{dtsUDT.c@{dtsUDT.c}}
}
\hyperlink{structDTS}{DTS} UDT transfer routines.  


{\tt \#include $<$pthread.h$>$}\par
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$unistd.h$>$}\par
{\tt \#include $<$string.h$>$}\par
{\tt \#include $<$netdb.h$>$}\par
{\tt \#include $<$ctype.h$>$}\par
{\tt \#include $<$sys/types.h$>$}\par
{\tt \#include $<$sys/stat.h$>$}\par
{\tt \#include $<$sys/time.h$>$}\par
{\tt \#include $<$fcntl.h$>$}\par
{\tt \#include $<$sys/errno.h$>$}\par
{\tt \#include $<$sys/socket.h$>$}\par
{\tt \#include $<$netinet/in.h$>$}\par
{\tt \#include $<$netinet/tcp.h$>$}\par
{\tt \#include $<$arpa/inet.h$>$}\par
{\tt \#include \char`\"{}dts.h\char`\"{}}\par
{\tt \#include \char`\"{}dtsUDT.h\char`\"{}}\par
{\tt \#include \char`\"{}dtsPSock.h\char`\"{}}\par
{\tt \#include \char`\"{}udtc.h\char`\"{}}\par
\subsection*{Defines}
\begin{CompactItemize}
\item 
\hypertarget{dtsUDT_8c_ad55e154f3cb5a056bb9e07d7b52cb37}{
\#define \textbf{\_\-PTCP\_\-SRC\_\-}}
\label{dtsUDT_8c_ad55e154f3cb5a056bb9e07d7b52cb37}

\item 
\hypertarget{dtsUDT_8c_25638b2e5b013d286aed09c9978e394b}{
\#define \textbf{UDT\_\-DEBUG}~0}
\label{dtsUDT_8c_25638b2e5b013d286aed09c9978e394b}

\item 
\hypertarget{dtsUDT_8c_15816ad43ecbc0876a738652e4a866a2}{
\#define \textbf{USE\_\-PTHREAD\_\-JOIN}}
\label{dtsUDT_8c_15816ad43ecbc0876a738652e4a866a2}

\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
int \hyperlink{dtsUDT_8c_e682abbad70a71cf6a836e5cae408ca6}{udtSpawnThreads} (void $\ast$worker, int nthreads, char $\ast$dir, char $\ast$fname, long fsize, int mode, int rate, int port, char $\ast$host, int verbose, pthread\_\-t $\ast$tids)
\begin{CompactList}\small\item\em Spawn a worker thread for the transfer. \item\end{CompactList}\item 
int $\ast$ \hyperlink{dtsUDT_8c_9fbe12a60574ef9f7e05f74fe3c2f8d9}{udtCollectThreads} (int nthreads, pthread\_\-t $\ast$tids)
\begin{CompactList}\small\item\em Collect worker threads for the transfer. \item\end{CompactList}\item 
void \hyperlink{dtsUDT_8c_50349f4c5c05a5ba807b7e4ab36cc6df}{udtSendFile} (void $\ast$data)
\begin{CompactList}\small\item\em Send a file to a remote \hyperlink{structDTS}{DTS}. \item\end{CompactList}\item 
void \hyperlink{dtsUDT_8c_cf6dc5be78f72753c0a2133b1c810262}{udtReceiveFile} (void $\ast$data)
\begin{CompactList}\small\item\em Read a file from a remote \hyperlink{structDTS}{DTS}. \item\end{CompactList}\item 
int \hyperlink{dtsUDT_8c_d8c34719bb2b37d8352267f0f986b42c}{udtSendStripe} (int sock, unsigned char $\ast$dbuf, long offset, int tnum, long maxbytes)
\begin{CompactList}\small\item\em Do actual transfer of data stripe to the socket. \item\end{CompactList}\item 
unsigned char $\ast$ \hyperlink{dtsUDT_8c_b66429cb336e0f433ec57e781ec35885}{udtReceiveStripe} (int sock, long offset, int tnum)
\begin{CompactList}\small\item\em Read data stripe from the socket connection. \item\end{CompactList}\item 
\hypertarget{dtsUDT_8c_e75a00414fad8bc81ece1f139508a440}{
void \textbf{udtComputeStripe} (long fsize, int nthreads, int tnum, long $\ast$chsize, long $\ast$start, long $\ast$end)}
\label{dtsUDT_8c_e75a00414fad8bc81ece1f139508a440}

\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
pthread\_\-mutex\_\-t \hyperlink{dtsUDT_8c_64bf8b572c913b0dd7971b5308e1f6db}{udt\_\-mutex} = PTHREAD\_\-MUTEX\_\-INITIALIZER
\item 
int \hyperlink{dtsUDT_8c_3e00d252a58a2aae580ca08e990104ee}{udt\_\-checksum\_\-policy} = CS\_\-NONE
\item 
\hypertarget{dtsUDT_8c_bc3bb7a68b2cea3f7db95cb764bce904}{
struct timeval \textbf{io\_\-tv}}
\label{dtsUDT_8c_bc3bb7a68b2cea3f7db95cb764bce904}

\item 
\hypertarget{dtsUDT_8c_4e3d0548c599124f2df64c499a8b0ee6}{
int \textbf{queue\_\-delay}}
\label{dtsUDT_8c_4e3d0548c599124f2df64c499a8b0ee6}

\item 
\hypertarget{dtsUDT_8c_e9c89e7ff1fbfe74ed32f3bb6b69193f}{
int \textbf{thread\_\-sem}}
\label{dtsUDT_8c_e9c89e7ff1fbfe74ed32f3bb6b69193f}

\item 
\hypertarget{dtsUDT_8c_99390fcf722f24689439904d1b546dce}{
\hyperlink{structDTS}{DTS} $\ast$ \textbf{dts}}
\label{dtsUDT_8c_99390fcf722f24689439904d1b546dce}

\item 
\hypertarget{dtsUDT_8c_bfe1ab56be631e48e5edc9f0f1381486}{
int \textbf{first\_\-write}}
\label{dtsUDT_8c_bfe1ab56be631e48e5edc9f0f1381486}

\end{CompactItemize}


\label{_details}
\hypertarget{_details}{}
\subsection{Detailed Description}
\hyperlink{structDTS}{DTS} UDT transfer routines. 

DTSUDT.C -- \hyperlink{structDTS}{DTS} UDT transfer routines.

\begin{Desc}
\item[Author:]Mike Fitzpatrick, Travis Semple, NOAO \end{Desc}
\begin{Desc}
\item[Date:]3/10/13 \end{Desc}


\subsection{Function Documentation}
\hypertarget{dtsUDT_8c_9fbe12a60574ef9f7e05f74fe3c2f8d9}{
\index{dtsUDT.c@{dtsUDT.c}!udtCollectThreads@{udtCollectThreads}}
\index{udtCollectThreads@{udtCollectThreads}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udtCollectThreads}]{\setlength{\rightskip}{0pt plus 5cm}int udtCollectThreads (int {\em nthreads}, \/  pthread\_\-t $\ast$ {\em tids})}}
\label{dtsUDT_8c_9fbe12a60574ef9f7e05f74fe3c2f8d9}


Collect worker threads for the transfer. 

UDTCOLLECTTHREADS -- Collect the worker threads for the transfer. Our onl job here is start a thread to rejoin the previously createed threads.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em nthreads}]number of threads to create \item[{\em tids}]thread IDs \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]status code \end{Desc}
\hypertarget{dtsUDT_8c_cf6dc5be78f72753c0a2133b1c810262}{
\index{dtsUDT.c@{dtsUDT.c}!udtReceiveFile@{udtReceiveFile}}
\index{udtReceiveFile@{udtReceiveFile}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udtReceiveFile}]{\setlength{\rightskip}{0pt plus 5cm}udtReceiveFile (void $\ast$ {\em data})}}
\label{dtsUDT_8c_cf6dc5be78f72753c0a2133b1c810262}


Read a file from a remote \hyperlink{structDTS}{DTS}. 

UDTRECEIVEFILE -- Receive a file from a remote \hyperlink{structDTS}{DTS}.

This function can be called to read a portion of a file from a remote host. Arguments are passed in through a generic 'data' pointer to the psArg struct defined for this 'stripe' of the data.

In this procedure, we act as a client in the connection, i.e. the transfer won't begin until we connect to a remote server sending the data.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em data}]caller thread data \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]nothing \end{Desc}


References dts\_\-fileOpen(), dts\_\-fileWrite(), dts\_\-makePath(), dts\_\-openUDTClientSocket(), dts\_\-preAlloc(), dts\_\-sandboxPath(), dts\_\-semDecr(), dtsErrLog(), dtsLog(), dtsTimeLog(), udt\_\-mutex, and udtReceiveStripe().

Referenced by dts\_\-xferPullFile(), and dts\_\-xferReceiveFile().\hypertarget{dtsUDT_8c_b66429cb336e0f433ec57e781ec35885}{
\index{dtsUDT.c@{dtsUDT.c}!udtReceiveStripe@{udtReceiveStripe}}
\index{udtReceiveStripe@{udtReceiveStripe}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udtReceiveStripe}]{\setlength{\rightskip}{0pt plus 5cm}uchar $\ast$ udtReceiveStripe (int {\em sock}, \/  long {\em offset}, \/  int {\em tnum})}}
\label{dtsUDT_8c_b66429cb336e0f433ec57e781ec35885}


Read data stripe from the socket connection. 

UDTRECEIVESTRIPE -- Do the actual transfer of the data stripe to the client connection. A 'stripe' of data is actually transferred in much smaller 'chunks' which can be tuned to be optimal for the given connection. The checksum policy allows us to perform a checksum of the data either for the entire stripe, or for each individual chunk. The former is generally more efficient as it involves fewer round-trips to the client (i.e. send the checksum and wait for verification before sending next chunk). File-level checksum policy is enforced by our parent.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em sock}]socket descriptor \item[{\em offset}]file offset for this stripe \item[{\em tnum}]thread (i.e. stripe) number\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]a pointer to the data read \end{Desc}


References dts\_\-debugLevel(), dts\_\-udtRead(), and dtsLog().

Referenced by udtReceiveFile().\hypertarget{dtsUDT_8c_50349f4c5c05a5ba807b7e4ab36cc6df}{
\index{dtsUDT.c@{dtsUDT.c}!udtSendFile@{udtSendFile}}
\index{udtSendFile@{udtSendFile}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udtSendFile}]{\setlength{\rightskip}{0pt plus 5cm}udtSendFile (void $\ast$ {\em data})}}
\label{dtsUDT_8c_50349f4c5c05a5ba807b7e4ab36cc6df}


Send a file to a remote \hyperlink{structDTS}{DTS}. 

UDTSENDFILE -- Send a file to a remote \hyperlink{structDTS}{DTS} using UDT.

This function can be called to send a portion of a file to a remote host. Arguments are passed in through a generic 'data' pointer to the psArg struct defined for this 'stripe' of the data.

In this procedure, we act as a server, i.e. we open the specified tcp/ip socket and wait for a client connection before beginning any transfer.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em data}]caller thread data \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]nothing \end{Desc}


References dts\_\-fileClose(), dts\_\-fileOpen(), dts\_\-fileRead(), dts\_\-makePath(), dts\_\-openUDTClientSocket(), dts\_\-sandboxPath(), dts\_\-semDecr(), dtsErrLog(), dtsLog(), dtsTimeLog(), udt\_\-mutex, and udtSendStripe().

Referenced by dts\_\-xferPushFile(), and dts\_\-xferSendFile().\hypertarget{dtsUDT_8c_d8c34719bb2b37d8352267f0f986b42c}{
\index{dtsUDT.c@{dtsUDT.c}!udtSendStripe@{udtSendStripe}}
\index{udtSendStripe@{udtSendStripe}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udtSendStripe}]{\setlength{\rightskip}{0pt plus 5cm}int udtSendStripe (int {\em sock}, \/  unsigned char $\ast$ {\em dbuf}, \/  long {\em offset}, \/  int {\em tnum}, \/  long {\em maxbytes})}}
\label{dtsUDT_8c_d8c34719bb2b37d8352267f0f986b42c}


Do actual transfer of data stripe to the socket. 

UDTSENDSTRIPE -- Do the actual transfer of the data stripe to the client connection. A 'stripe' of data is actually transferred in much smaller 'chunks' which can be tuned to be optimal for the given connection. The checksum policy allows us to perform a checksum of the data either for the entire stripe, or for each individual chunk. The former is generally more efficient as it involves fewer round-trips to the client (i.e. send the checksum and wait for verification before sending next chunk). File-level checksum policy is enforced by our parent.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em sock}]socket descriptor \item[{\em dbuf}]data buffer \item[{\em offset}]file offset for this stripe \item[{\em tnum}]thread number \item[{\em maxbytes}]max bytes to transfer\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]number of chunks sent \end{Desc}


References dts\_\-debugLevel(), dts\_\-udtWrite(), dtsErrLog(), and dtsTimeLog().

Referenced by udtSendFile().\hypertarget{dtsUDT_8c_e682abbad70a71cf6a836e5cae408ca6}{
\index{dtsUDT.c@{dtsUDT.c}!udtSpawnThreads@{udtSpawnThreads}}
\index{udtSpawnThreads@{udtSpawnThreads}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udtSpawnThreads}]{\setlength{\rightskip}{0pt plus 5cm}int udtSpawnThreads (void $\ast$ {\em worker}, \/  int {\em nthreads}, \/  char $\ast$ {\em dir}, \/  char $\ast$ {\em fname}, \/  long {\em fsize}, \/  int {\em mode}, \/  int {\em rate}, \/  int {\em port}, \/  char $\ast$ {\em host}, \/  int {\em verbose}, \/  pthread\_\-t $\ast$ {\em tids})}}
\label{dtsUDT_8c_e682abbad70a71cf6a836e5cae408ca6}


Spawn a worker thread for the transfer. 

UDTSPAWNTHREADS -- Spawn a worker thread for the transfer. All we do here is start a thread to run the function passed in. This may be used to either read or write the data.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em worker}]worker function \item[{\em nthreads}]number of threads to create \item[{\em dir}]working directory \item[{\em fname}]file name \item[{\em fsize}]file size \item[{\em mode}]transfer mode (push or pull) \item[{\em rate}]transfer rate (Mbps) \item[{\em port}]client base port number \item[{\em host}]client host name \item[{\em verbose}]verbose output flag \item[{\em tids}]thread id array\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]status code \end{Desc}


References dtsErrLog(), and psComputeStripe().

Referenced by dts\_\-xferPullFile(), dts\_\-xferPushFile(), dts\_\-xferReceiveFile(), and dts\_\-xferSendFile().

\subsection{Variable Documentation}
\hypertarget{dtsUDT_8c_3e00d252a58a2aae580ca08e990104ee}{
\index{dtsUDT.c@{dtsUDT.c}!udt\_\-checksum\_\-policy@{udt\_\-checksum\_\-policy}}
\index{udt\_\-checksum\_\-policy@{udt\_\-checksum\_\-policy}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udt\_\-checksum\_\-policy}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf udt\_\-checksum\_\-policy} = CS\_\-NONE}}
\label{dtsUDT_8c_3e00d252a58a2aae580ca08e990104ee}


FIXME -- CS\_\-STRIPE and CS\_\-PACKET not working...... 

Referenced by dts\_\-udtRead(), and dts\_\-udtWrite().\hypertarget{dtsUDT_8c_64bf8b572c913b0dd7971b5308e1f6db}{
\index{dtsUDT.c@{dtsUDT.c}!udt\_\-mutex@{udt\_\-mutex}}
\index{udt\_\-mutex@{udt\_\-mutex}!dtsUDT.c@{dtsUDT.c}}
\subsubsection[{udt\_\-mutex}]{\setlength{\rightskip}{0pt plus 5cm}pthread\_\-mutex\_\-t {\bf udt\_\-mutex} = PTHREAD\_\-MUTEX\_\-INITIALIZER}}
\label{dtsUDT_8c_64bf8b572c913b0dd7971b5308e1f6db}


Mutex lock for thread startup to protect file I/O. 

Referenced by udtReceiveFile(), and udtSendFile().